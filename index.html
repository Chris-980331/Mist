<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>真实玻璃起雾+水滴流下效果</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #222; }

        /* 背景图：你可以替换成任何你喜欢的图片链接 */
        #background {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            /* 这里换了一张更适合雨天的背景 */
            background: url('https://images.unsplash.com/photo-1515694346937-94d85e41e6f0?q=80&w=2000') no-repeat center center;
            background-size: cover;
            z-index: 1;
        }

        /* 雾气画布 */
        #fogCanvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2;
            /* 给画布加一点整体模糊，让擦出来的边缘更柔和 */
            filter: blur(2px);
        }
    </style>
</head>
<body>

    <div id="background"></div>
    <canvas id="fogCanvas"></canvas>

    <script>
        const canvas = document.getElementById('fogCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let isDrawing = false;
        let lastX = 0; let lastY = 0;

        // --- 水滴粒子系统 ---
        let droplets = []; // 存放活跃水滴的数组

        class Droplet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                // 水滴大小随机
                this.radius = Math.random() * 2 + 1;
                // 下落速度随机，制造错落感
                this.speed = Math.random() * 1.5 + 0.5;
            }
            update() {
                this.y += this.speed; // 模拟重力向下移动
                // 可选：让水滴稍微加速下落，更真实
                // this.speed += 0.02;
            }
        }
        // -------------------

        function initCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            drawInitialFog();
            animateDroplets(); // 启动水滴动画循环
        }

        // 1. 绘制初始雾气
        function drawInitialFog() {
            ctx.globalCompositeOperation = 'source-over';
            // 使用带一点点蓝灰色的白，模拟冷凝水汽
            ctx.fillStyle = 'rgba(230, 235, 240, 0.85)';
            ctx.fillRect(0, 0, width, height);
        }

        // 2. 手指擦拭逻辑
        function wipe(x, y) {
            ctx.globalCompositeOperation = 'destination-out';
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = 40; // 手指宽度
            // 边缘羽化，模拟水渍抹开的效果
            ctx.shadowBlur = 20;
            ctx.shadowColor = 'black';

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();

            lastX = x;
            lastY = y;

            // --- 生成水滴的核心逻辑 ---
            // 当手指移动时，有一定概率（这里是 5%）在当前位置生成一个下滑的水滴
            if (Math.random() > 0.95) {
                droplets.push(new Droplet(x, y));
            }
        }

        // 3. 水滴动画循环
        function animateDroplets() {
            // 设置为擦除模式，且不需要羽化（水滴边缘比较锐利）
            ctx.globalCompositeOperation = 'destination-out';
            ctx.shadowBlur = 0;

            for (let i = droplets.length - 1; i >= 0; i--) {
                const drop = droplets[i];
                drop.update();

                // 绘制水滴轨迹（擦除雾气）
                ctx.beginPath();
                // 画一个稍微拉长的椭圆，模拟下坠变形
                ctx.ellipse(drop.x, drop.y, drop.radius, drop.radius * 1.3, 0, 0, Math.PI * 2);
                ctx.fill();

                // 如果水滴流出屏幕底部，从数组中移除，节省内存
                if (drop.y > height + 50) {
                    droplets.splice(i, 1);
                }
            }
            requestAnimationFrame(animateDroplets);
        }

        // --- 事件监听适配 ---
        function startDrawing(e) {
            isDrawing = true;
            const pos = getPos(e);
            lastX = pos.x; lastY = pos.y;
        }
        function move(e) {
            if (!isDrawing) return;
            const pos = getPos(e);
            wipe(pos.x, pos.y);
        }
        function getPos(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: clientX, y: clientY };
        }

        // 触摸事件（手机）
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrawing(e); }, { passive: false });
        window.addEventListener('touchmove', (e) => { e.preventDefault(); move(e); }, { passive: false });
        window.addEventListener('touchend', () => isDrawing = false);

        // 鼠标事件（电脑）
        canvas.addEventListener('mousedown', startDrawing);
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', () => isDrawing = false);
        window.addEventListener('resize', initCanvas);

        initCanvas();
    </script>
</body>
</html>